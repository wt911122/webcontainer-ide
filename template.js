export const files = {
	"index.html": {
		"file": {
			"contents": "<!doctype html>\n<html lang=\"en\">\n    <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Vite + React</title>\n    </head>\n    <body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"/src/main.jsx\"></script>\n    </body>\n</html>"
		}
	},
	"package.json": {
		"file": {
			"contents": "{\n    \"name\": \"antd-demo\",\n    \"private\": true,\n    \"version\": \"0.0.0\",\n    \"type\": \"module\",\n    \"scripts\": {\n        \"dev\": \"vite\",\n        \"build\": \"vite build\",\n        \"lint\": \"eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0\",\n        \"preview\": \"vite preview\"\n    },\n    \"devDependencies\": {\n        \"@vitejs/plugin-react\": \"^4.2.0\",\n        \"rollup-plugin-external-globals\": \"^0.9.1\",\n        \"vite\": \"^5.0.4\"\n    },\n    \"dependencies\": {\n        \"antd\": \"^5.11.5\",\n        \"react\": \"^18.2.0\",\n        \"react-dom\": \"^18.2.0\"\n    }\n}\n"
		}
	},
	"src": {
		"directory": {
			"App.jsx": {
				"file": {
					"contents": "import { useState } from 'react'\nimport './App.css'\nimport { Button } from 'antd';\n\nfunction App() {\n  const [count, setCount] = useState(0)\n\n  return (\n    <>\n      <h1>Vite + React</h1>\n      <div className=\"card\">\n        <button onClick={() => setCount((count) => count + 1)}>\n          count is {count}\n        </button>\n        <p>\n          Edit <code>src/App.jsx</code> and save to test HMR\n        </p>\n      </div>\n      <Button type=\"primary\">Primary Button</Button>\n      <p className=\"read-the-docs\">\n        Click on the Vite and React logos to learn more\n      </p>\n    </>\n  )\n}\n\nexport default App"
				}
			},
			"Empty.jsx": {
				"file": {
					"contents": "import './empty.css';\n\nexport default function () {\n    return (\n        <div className=\"empty-slot\" emptyslot=\"true\"></div>\n    )\n}"
				}
			},
			"empty.css": {
				"file": {
					"contents": ".empty-slot{\n    background: #f7f8fa;\n    border: 1px dashed #c3c3c3;\n    text-align: center;\n    color: #999;\n    min-height: 30px;\n    min-width: 90px;\n    width: 100%;\n}\n.empty-slot::after {   \n    content: \"+\";\n    font-size: 20px;\n    display: inline-block;\n}"
				}
			},
			"index.css": {
				"file": {
					"contents": "body {\n    margin: 0;\n    place-items: center;\n    min-width: 320px;\n    min-height: 300px;\n}\nbutton {\n    cursor: inherit !important;\n}\n[ide-dragging='true'] {\n    opacity: 0.5!important;\n}\n\n[dropgap='true'] {\n    padding: 10px;\n    border: 1px dashed #4a88e8;\n    transition: padding 0.2s;\n    box-sizing: border-box; /** 避免宽度撑开，超出 */\n}\n/* 子页面容器禁用 dropgap，bugid 2693320101095168 */\n[dropgap='true'][vusion-node-tag*=\"-router-view\"] {\n    border: none;\n    padding: 0;\n}\n\nbody[ide-cursor=\"copy\"] {\n    cursor: copy!important;\n}\nbody[ide-cursor=\"auto\"] {\n    cursor: auto;\n}\nbody[ide-cursor=\"grabbing\"] {\n    cursor: grabbing!important;\n}\nbody[ide-cursor=\"not-allowed\"] {\n    cursor: not-allowed!important;\n}\n"
				}
			},
			"main.jsx": {
				"file": {
					"contents": "import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport App from './App.jsx'\nimport './index.css'\nimport './proxy.js'\n\nReactDOM.createRoot(document.getElementById('root')).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n)"
				}
			},
			"proxy.js": {
				"file": {
					"contents": "(function () {\n    \nconst status = {\n    isDragging: false,\n    mouseDownPosition: [],\n    draggingElem: null,\n}\n\nfunction postMessageToIDE(data) {\n    window.parent.postMessage(data, '*')\n}\n\nfunction oneTripToIDE(data) {\n    let uuid = `oneTripToIDE-${oneTripToIDE.uuid++}`;\n    let resolve;\n    const promise = new Promise(r => {\n        resolve = r;\n    })\n    const f = (event) => {\n        const data = event.data;\n        if(data.uuid === uuid) {\n            resolve(data.response);\n            window.removeEventListener('message', f)\n        }\n    }\n    window.addEventListener('message', f)\n    window.parent.postMessage({\n        uuid,\n        ...data\n    }, '*')\n    return promise;\n}\noneTripToIDE.uuid = 0;\n\nconst CAPTURE_EVENT = { capture: true }\n\nfunction pickKeys(obj, keys) {\n    const r = {};\n    keys.forEach(k => {\n        if(k in obj){\n            r[k] = obj[k];\n        }\n    })\n    return r;\n}\n\nfunction lockTarget(e) {\n    const domtree = document.elementsFromPoint(e.clientX, e.clientY);\n    const emptyslot = domtree?.[0]?.hasAttribute('emptyslot');\n    if(emptyslot) {\n        return domtree[0];\n    }\n    const element = domtree.find(elem => elem.hasAttribute('nodepath'));\n    \n    if(element) {\n        return element\n    }\n    return null;\n}\n\n\nfunction findParentWithNodePath(elem) {\n    let p = elem.parentNode;\n    while(p !== document.body) {\n        if(p.hasAttribute('nodepath')) {\n            return p;\n        }\n        p = p.parentNode;\n    }\n    return null;\n}\n\nfunction iterateUpWithNodePath(elem, callback) {\n    let skipFirstParent = elem.hasAttribute('emptyslot') || elem.getAttribute('ide-iscontainer') === 'false';\n    let p = elem.parentNode;\n    let flag = false;;\n    while(p !== document.body) {\n        if(p.hasAttribute('nodepath')) {\n            if(skipFirstParent) {\n                skipFirstParent = false;\n                p = p.parentNode;\n                continue;\n            }\n            callback(p)\n            flag = true;\n        }\n        p = p.parentNode;\n    }\n    return flag;\n}\n\nfunction resolveEvent(e) {\n    return pickKeys(e, [\n        'ctrlKey',\n        'clientX',\n        'clientY',\n        'deltaX',\n        'deltaY',\n    ])\n}\n\nwindow.addEventListener('wheel', (e) => {\n    if(e.ctrlKey) { \n        e.preventDefault();\n    } \n    postMessageToIDE({\n        type: 'Event',\n        name: 'wheel',\n        payload: {\n            eventMeta: resolveEvent(e),\n        }\n    })\n}, { passive: false });\n\nwindow.addEventListener('scroll', (e) => {\n    if(e.ctrlKey) { \n        e.preventDefault();\n    } \n    postMessageToIDE({\n        type: 'Event',\n        name: 'scroll',\n        payload: {\n            eventMeta: resolveEvent(e),\n        }\n    })\n}, CAPTURE_EVENT);\n\nfunction isElementInline(element) {\n    const computedStyle = getComputedStyle(element);\n    return computedStyle.display === 'inline' || computedStyle.display === 'inline-block';\n}\n\nfunction prepareElementTransferInfomation(element) {\n    const payload = {\n        target: null,\n    };\n    if(element) {\n        if(element.hasAttribute('emptyslot')) {\n            const elem = findParentWithNodePath(element);\n            const target = elem.getAttribute('nodepath');\n            payload.rects = Array.from(element.getClientRects());\n            payload.target = target;\n            payload.isEmptySlot = true;\n        } \n        if(element.hasAttribute('nodepath')) {\n            // const box = element.getBoundingClientRect();\n            payload.target = element.getAttribute('nodepath');\n            // payload.boundingbox = box;\n            payload.elemStyle = {\n                inline: isElementInline(element),\n            }\n            const rects = element.getClientRects();\n            payload.rects = Array.from(rects);\n        }\n    }\n    return payload;\n}\n\nwindow.addEventListener('mousedown', (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    status.mouseDownPosition = [e.clientX, e.clientY];\n    const element = lockTarget(e);\n    if(element) {\n        let p = [e.clientX, e.clientY]\n        let _d = 0;\n        const f = (e) => {\n            const x = Math.abs(e.clientX - p[0]);\n            const y = Math.abs(e.clientY - p[1]);\n            p[0] = e.clientX;\n            p[1] = e.clientY;\n            _d += x + y;\n            if(_d > 20) {\n                status.draggingElem = element;\n                element.setAttribute('ide-dragging', true)\n                postMessageToIDE({\n                    type: 'Event',\n                    name: 'dragstart',\n                    payload: {\n                        eventMeta: resolveEvent(e),\n                        elementInfo: prepareElementTransferInfomation(element),\n                    }\n                });\n                window.removeEventListener('mousemove', f, CAPTURE_EVENT);    \n            }\n        }\n        window.addEventListener('mouseup', () => {\n            window.removeEventListener('mousemove', f, CAPTURE_EVENT);    \n        }, {\n            ...CAPTURE_EVENT,\n            once: true,\n        })\n        window.addEventListener('mousemove', f, CAPTURE_EVENT);\n    }\n}, CAPTURE_EVENT);\n\nfunction debounce(callback, timeout) {\n    let _timer\n    return function(continued, ...argus) {\n        if(_timer) {\n            clearTimeout(_timer);\n        } \n        if(continued) {\n            _timer = setTimeout(() => {\n                callback(...argus);\n            }, timeout);\n        }\n    }\n}\n\nfunction expandContainerGap(elem) {\n    if(elem.getAttribute('ide-iscontainer') === 'true'){\n        elem.setAttribute('dropgap', true);\n    }\n}\n\nfunction releaseContainerGap() {\n    const elems = document.querySelectorAll(`[dropgap]`);\n    Array.from(elems).forEach(el => {\n        el.removeAttribute('dropgap')\n    })\n    hesitateWhenDragging(false);\n}\n\nfunction releaseDragging() {\n    status.isDragging = false;\n    if(status.draggingElem) {\n        status.draggingElem.removeAttribute('ide-dragging')\n    }\n    status.draggingElem = null;\n    releaseContainerGap();\n}\n\nconst hesitateWhenDragging = debounce(function(element) {\n    if(element) {\n        const findSome = iterateUpWithNodePath(element, expandContainerGap)\n        if(findSome){\n            postMessageToIDE({\n                type: 'Event',\n                name: 'hesitateWhenDragging',\n                payload: {\n                    elementInfo: prepareElementTransferInfomation(element),\n                }\n            });\n        }\n    }\n}, 1000)\n\nwindow.addEventListener('mousemove', (e) => {\n    e.stopPropagation();\n    const element = lockTarget(e);\n    \n    if(status.isDragging) {\n        if(status.draggingElem && status.draggingElem.contains(element)) {\n            postMessageToIDE({\n                type: 'Event',\n                name: 'dragover',\n                payload: {\n                    eventMeta: resolveEvent(e),\n                    notAllowed: true,\n                }\n            });\n            document.body.setAttribute('ide-cursor', 'not-allowed');\n            return;\n        }\n        hesitateWhenDragging(true, element);\n        postMessageToIDE({\n            type: 'Event',\n            name: 'dragover',\n            payload: {\n                eventMeta: resolveEvent(e),\n                elementInfo: prepareElementTransferInfomation(element),\n            }\n        });\n    } else {\n        postMessageToIDE({\n            type: 'Event',\n            name: 'mousemove',\n            payload: {\n                eventMeta: resolveEvent(e),\n                elementInfo: prepareElementTransferInfomation(element),\n            }\n        });\n    }\n    \n}, CAPTURE_EVENT);\nwindow.addEventListener('mouseup', (e) => {\n    if(status.isDragging) {\n        e.preventDefault();\n        e.stopPropagation();\n        status.isDragging = false;\n        const element = lockTarget(e);\n        postMessageToIDE({\n            type: 'Event',\n            name: 'dragend',\n            payload: {\n                eventMeta: resolveEvent(e),\n                elementInfo: prepareElementTransferInfomation(element),\n            }\n        });\n        hesitateWhenDragging(false);\n    }\n}, CAPTURE_EVENT);\n\n\nwindow.addEventListener('click', (e) => {\n    if(status.mouseDownPosition[0] !== e.clientX || status.mouseDownPosition[1] !== e.clientY){\n        return;\n    }\n    const element = lockTarget(e);\n    \n    postMessageToIDE({\n        type: 'Event',\n        name: 'click',\n        payload: {\n            eventMeta: resolveEvent(e),\n            elementInfo: prepareElementTransferInfomation(element),\n        }\n    });\n    // collectSubElements(element);\n}, CAPTURE_EVENT)\n\n// window.addEventListener('dragover', e => {\n//     const element = lockTarget(e);\n//     console.log(element)\n// })\n\n// window.addEventListener('dragover', e => {\n//     e.preventDefault();\n//     const element = lockTarget(e);\n//     if(element) {\n//         collectSubElements(element);\n//     }\n\n// }, { capture: true });\n\n/*\nasync function collectSiblingElements(element) {\n    const response = await oneTripToIDE({\n        type: 'Method',\n        name: 'getSiblingNodePath',\n        payload: element.getAttribute('nodepath'),\n    })\n    console.log(response);\n    return response.map(r => document.querySelector(`[nodepath=\"${r}\"]`))\n}\n\nasync function collectParentElements(element) {\n    const response = await oneTripToIDE({\n        type: 'Method',\n        name: 'getParentNodePath',\n        payload: element.getAttribute('nodepath'),\n    })\n    console.log(response);\n    return response.map(r => document.querySelector(`[nodepath=\"${r}\"]`))\n}*/ \n\nwindow.addEventListener('message', (event) => {\n    const data = event.data;\n    if(data.type === 'Event') {\n        switch(data.name) {\n            case 'startDragging':\n                status.isDragging = true;\n                break;\n            case 'stopDragging':\n                releaseDragging();\n                break;\n        }\n    }\n\n    if(data.type === 'Method') {\n      if(methods[data.name]) {\n        const uuid = data.uuid;\n        try {\n            const response = methods[data.name](data.payload);\n            event.source.postMessage({\n                type: 'Response',\n                result: 'success',\n                uuid,\n                response,\n            }, event.origin)\n        } catch(err) {\n            event.source.postMessage({\n                type: 'Response',\n                result: 'failed',\n                uuid,\n                err,\n            }, event.origin)\n        }\n        \n      }\n  }\n})\n\nconst observer = new ResizeObserver(() => {\n    console.log(document.body.scrollHeight)\n    postMessageToIDE({\n        type: 'Event',\n        name: 'resizeObserver',\n        payload: {\n            scrollHeight: document.body.scrollHeight\n        }\n    })\n});\n\nconst methods = {\n    getElementInfoByNodePath(payload) {\n        const elem = document.querySelector(`[nodepath=\"${payload.nodePath}\"]`);\n        return prepareElementTransferInfomation(elem)\n    },\n    getElementsInfoByNodePath(payload) {\n        const result = {};\n        payload.nodePaths.forEach((path) => {\n            const elem = document.querySelector(`[nodepath=\"${path}\"]`);\n            result[path] = prepareElementTransferInfomation(elem)\n        });\n        return result;\n    },\n    setCursor(payload) {\n        document.body.setAttribute('ide-cursor', payload.cursor);\n    },\n    startObserveRootNodeSize(payload) { \n        const elem = document.querySelector(payload.selector);\n        if(elem) {\n            observer.observe(elem);\n        }\n    },\n}\n\npostMessageToIDE({\n    type: 'Event',\n    name: 'proxyReady',\n    payload: {}\n})\n})();"
				}
			}
		}
	},
	"vite.config.js": {
		"file": {
			"contents": "import { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport externalGlobals from \"rollup-plugin-external-globals\"; \n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  build: {\n    rollupOptions: {\n      external: [\"antd\"],\n      plugins: [\n        externalGlobals({\n          \"antd\": \"antd\",\n        }),\n      ],\n    }\n  }\n})\n"
		}
	}
}